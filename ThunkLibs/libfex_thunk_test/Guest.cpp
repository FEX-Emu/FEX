/*
$info$
tags: thunklibs|fex_thunk_test
$end_info$
*/

#include <atomic>
#include <condition_variable>
#include <mutex>
#include <thread>
#include <unordered_map>

#include "common/Guest.h"
#include "api.h"

#include "thunkgen_guest_libfex_thunk_test.inl"

#if 0
struct OnStart {
  std::thread thr;
  std::atomic<bool> done { false };
  std::mutex m;
  std::condition_variable var;

  OnStart() : thr([this]() {
    struct { unsigned id = 1; } args;
    fexthunks_fex_register_async_worker_thread(&args);
  }) {}

  ~OnStart() {
    struct { unsigned id = 1; } args;
    fexthunks_fex_unregister_async_worker_thread(&args);
    thr.join();
  }
} on_start;

extern "C" void SetAsyncCallback(void (*cb)()) {
  fexfn_pack_SetAsyncCallback(cb);
}
#endif



/******************************
 * COMMON DEFS FOLLOW
 *****************************/
template<typename PFM>
struct pmd_traits;
template<typename Parent, typename Data>
struct pmd_traits<Data Parent::*> {
    using parent_t = Parent;
    using member_t = Data;
};

using const_void_ptr = const void*;

/******************************
 * MANUAL GEN FOLLOWS
 *****************************/

template<auto PMD>
static typename pmd_traits<decltype(PMD)>::member_t
fex_custom_repack(const typename pmd_traits<decltype(PMD)>::member_t& from);

// Entities created by "use_custom_repack" annotation on VkImageCreateInfo and on &VkImageCreateInfo::pNext
void fexfn_destroy(TestStruct1& a);
void fexfn_destroy(TestStruct2& a);

template<auto PMD>
struct pmd_as_tag {
    // Allow to initialize this from a member pointer (e.g. &TestStruct1::Next)
    pmd_as_tag(const decltype(PMD)&) {}
};

template<>
typename pmd_traits<decltype(&TestStruct1::Next)>::member_t
fex_custom_repack<&TestStruct1::Next>(const typename pmd_traits<decltype(&TestStruct1::Next)>::member_t& from);
template<>
typename pmd_traits<decltype(&TestStruct2::Next)>::member_t
fex_custom_repack<&TestStruct2::Next>(const typename pmd_traits<decltype(&TestStruct2::Next)>::member_t& from);

// Guest.h definitions

// Autogenerated
template<typename T>
struct fex_host_representation {
    T data;

    ~fex_host_representation() {
  fprintf(stderr, "Hello from %s\n", __FUNCTION__);
        fexfn_destroy(data);
  fprintf(stderr, "Hello from %s\n", __FUNCTION__);
    }
};

template<typename T>
using guest = T;

fex_host_representation<TestStruct1> Repack(const guest<TestStruct1>& from) {
  fex_host_representation<TestStruct1> to {};
  to.data.Type = from.Type;
  to.data.Next = from.Next;

  // Regular repacking for members after pNext
  to.data.Data1 = from.Data1;
  to.data.Data2 = from.Data2;

  to.data.Next = fex_custom_repack<&TestStruct1::Next>(from.Next);

  return to;
}

fex_host_representation<TestStruct2> Repack(const guest<TestStruct2>& from) {
  fex_host_representation<TestStruct2> to {};
  to.data.Type = from.Type;
  to.data.Next = from.Next;

  // Regular repacking for members after pNext
  to.data.Data1 = from.Data1;

  to.data.Next = fex_custom_repack<&TestStruct2::Next>(from.Next);

  return to;
}

extern "C" void TestFunction(TestStruct1* a_1) {

    struct {
        // TODO: Need some magic to turn fex_host_rep<type*> into fex_host_rep<type>* ?
//        fex_host_representation<TestStruct1>* a_1;
        TestStruct1* a_1;
    } args;

//    auto tmp_a_1 = Repack(*a_1);
//    args.a_1 = &tmp_a_1;
    args.a_1 = a_1;

  fprintf(stderr, "Hello from %s\n", __FUNCTION__);
    fexthunks_libfex_thunk_test_TestFunction(&args);
  fprintf(stderr, "Hello from %s\n", __FUNCTION__);

    // Implicitly runs fexfn_destroy via ~fex_host_representation() here
}


/******************************
 * ACTUAL MANUAL CODE FOLLOWS
 *****************************/

extern "C" void default_destroy(const TestBaseStruct& source) {
    // TODO: Traverse pNext linked list and delete sub-structures
}

__attribute__((alias("default_destroy"))) void fexfn_destroy(TestStruct1& data);
__attribute__((alias("default_destroy"))) void fexfn_destroy(TestStruct2& data);

template<StructType TypeIndex, typename Type>
static const TestBaseStruct* convert(const TestBaseStruct* source) {
    auto child = new fex_host_representation<Type>;
    *child = Repack(*reinterpret_cast<guest<Type>*>((void*)(source))); // TODO: Use proper cast?
    return (const TestBaseStruct*)child; // TODO: Use proper cast?
}

template<StructType TypeIndex, typename Type>
inline constexpr std::pair<StructType, const TestBaseStruct*(*)(const TestBaseStruct*)> converters =
  { TypeIndex, convert<TypeIndex, Type> };


static std::unordered_map<StructType, const TestBaseStruct*(*)(const TestBaseStruct*)> next_handlers {
    converters<StructType::Struct1, TestStruct1>,
    converters<StructType::Struct2, TestStruct2>,
};

// Normally, we would implement fex_custom_repack individually for each customized struct.
// In this case, they all need the same repacking, so we just implement it once and alias all fex_custom_repack instances
extern "C" const_void_ptr default_fex_custom_repack(const const_void_ptr& source) {
    if (!source) {
        return nullptr;
    }

    auto typed_source = reinterpret_cast<const TestBaseStruct*>(source);
    auto child = next_handlers.at(typed_source->Type)(typed_source);
    return child;
}

template<> __attribute__((alias("default_fex_custom_repack"))) const_void_ptr fex_custom_repack<&TestStruct1::Next>(const const_void_ptr&);
template<> __attribute__((alias("default_fex_custom_repack"))) const_void_ptr fex_custom_repack<&TestStruct2::Next>(const const_void_ptr&);

LOAD_LIB(libfex_thunk_test)
